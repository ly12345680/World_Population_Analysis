{"ast":null,"code":"import bbox from \"./bbox.js\";\nimport untransform from \"./untransform.js\";\nexport default function (topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be ≥2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0],\n      y0 = box[1],\n      x1 = box[2],\n      y1 = box[3],\n      n;\n    transform = {\n      scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1],\n      translate: [x0, y0]\n    };\n  } else {\n    box = topology.bbox;\n  }\n  var t = untransform(transform),\n    box,\n    key,\n    inputs = topology.objects,\n    outputs = {};\n  function quantizePoint(point) {\n    return t(point);\n  }\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\":\n        output = {\n          type: \"GeometryCollection\",\n          geometries: input.geometries.map(quantizeGeometry)\n        };\n        break;\n      case \"Point\":\n        output = {\n          type: \"Point\",\n          coordinates: quantizePoint(input.coordinates)\n        };\n        break;\n      case \"MultiPoint\":\n        output = {\n          type: \"MultiPoint\",\n          coordinates: input.coordinates.map(quantizePoint)\n        };\n        break;\n      default:\n        return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n  function quantizeArc(input) {\n    var i = 0,\n      j = 1,\n      n = input.length,\n      p,\n      output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}","map":{"version":3,"names":["bbox","untransform","topology","transform","Error","scale","n","Math","floor","box","x0","y0","x1","y1","translate","t","key","inputs","objects","outputs","quantizePoint","point","quantizeGeometry","input","output","type","geometries","map","coordinates","id","properties","quantizeArc","i","j","length","p","Array","arcs"],"sources":["/Users/nguyenhaiharry/Library/CloudStorage/OneDrive-VietNamNationalUniversity-HCMINTERNATIONALUNIVERSITY/Desktop/Sem1_2023-2024/DVDS/World_Population_Analysis/global-population/population-analysis/node_modules/topojson-client/src/quantize.js"],"sourcesContent":["import bbox from \"./bbox.js\";\nimport untransform from \"./untransform.js\";\n\nexport default function(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be ≥2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}