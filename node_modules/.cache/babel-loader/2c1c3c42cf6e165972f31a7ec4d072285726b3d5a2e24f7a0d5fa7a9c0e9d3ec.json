{"ast":null,"code":"import { object } from \"./feature.js\";\nimport stitch from \"./stitch.js\";\nfunction planarRingArea(ring) {\n  var i = -1,\n    n = ring.length,\n    a,\n    b = ring[n - 1],\n    area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nexport default function (topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n}\nexport function mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n    polygons = [],\n    groups = [];\n  objects.forEach(geometry);\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\":\n        o.geometries.forEach(geometry);\n        break;\n      case \"Polygon\":\n        extract(o.arcs);\n        break;\n      case \"MultiPolygon\":\n        o.arcs.forEach(extract);\n        break;\n    }\n  }\n  function extract(polygon) {\n    polygon.forEach(function (ring) {\n      ring.forEach(function (arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n  function area(ring) {\n    return planarRingArea(object(topology, {\n      type: \"Polygon\",\n      arcs: [ring]\n    }).coordinates[0]);\n  }\n  polygons.forEach(function (polygon) {\n    if (!polygon._) {\n      var group = [],\n        neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function (ring) {\n          ring.forEach(function (arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function (polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n  polygons.forEach(function (polygon) {\n    delete polygon._;\n  });\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function (polygons) {\n      var arcs = [],\n        n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function (polygon) {\n        polygon.forEach(function (ring) {\n          ring.forEach(function (arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n      return arcs;\n    }).filter(function (arcs) {\n      return arcs.length > 0;\n    })\n  };\n}","map":{"version":3,"names":["object","stitch","planarRingArea","ring","i","n","length","a","b","area","Math","abs","topology","mergeArcs","apply","arguments","objects","polygonsByArc","polygons","groups","forEach","geometry","o","type","geometries","extract","arcs","polygon","arc","push","coordinates","_","group","neighbors","pop","map","k","ki","t","filter"],"sources":["/Users/nguyenhaiharry/Library/CloudStorage/OneDrive-VietNamNationalUniversity-HCMINTERNATIONALUNIVERSITY/Desktop/Sem1_2023-2024/DVDS/World_Population_Analysis/global-population/population-analysis/node_modules/topojson-client/src/merge.js"],"sourcesContent":["import {object} from \"./feature.js\";\nimport stitch from \"./stitch.js\";\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nexport default function(topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n}\n\nexport function mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"Polygon\": extract(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function(ring) {\n      ring.forEach(function(arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n  }\n\n  polygons.forEach(function(polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function(polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function(polygons) {\n      var arcs = [], n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function(polygon) {\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    }).filter(function(arcs) {\n      return arcs.length > 0;\n    })\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}